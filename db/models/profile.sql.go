// Code generated by sqlc. DO NOT EDIT.
// source: profile.sql

package models

import (
	"context"
	"time"
)

const createProfile = `-- name: CreateProfile :one
INSERT INTO profiles
(user_id, first_name, last_name, dob, 
address_line1, address_line2, city, state, country, postal_code, 
primary_phone, secondary_phone, 
primary_email, secondary_email, created_at, updated_at) 
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING user_id, first_name, last_name, dob, address_line1, address_line2, city, state, country, postal_code, primary_phone, secondary_phone, primary_email, secondary_email, created_at, updated_at
`

type CreateProfileParams struct {
	UserID         string      `json:"user_id"`
	FirstName      string      `json:"first_name"`
	LastName       string      `json:"last_name"`
	Dob            time.Time   `json:"dob"`
	AddressLine1   string      `json:"address_line1"`
	AddressLine2   string      `json:"address_line2"`
	City           string      `json:"city"`
	State          string      `json:"state"`
	Country        string      `json:"country"`
	PostalCode     string      `json:"postal_code"`
	PrimaryPhone   string      `json:"primary_phone"`
	SecondaryPhone string      `json:"secondary_phone"`
	PrimaryEmail   string      `json:"primary_email"`
	SecondaryEmail string      `json:"secondary_email"`
	CreatedAt      interface{} `json:"created_at"`
	UpdatedAt      interface{} `json:"updated_at"`
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (Profile, error) {
	row := q.queryRow(ctx, q.createProfileStmt, createProfile,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.Dob,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.Country,
		arg.PostalCode,
		arg.PrimaryPhone,
		arg.SecondaryPhone,
		arg.PrimaryEmail,
		arg.SecondaryEmail,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Profile
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Dob,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.PrimaryEmail,
		&i.SecondaryEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProfile = `-- name: GetProfile :one
SELECT user_id, first_name, last_name, dob, address_line1, address_line2, city, state, country, postal_code, primary_phone, secondary_phone, primary_email, secondary_email, created_at, updated_at FROM profiles WHERE user_id = $1
`

func (q *Queries) GetProfile(ctx context.Context, userID string) (Profile, error) {
	row := q.queryRow(ctx, q.getProfileStmt, getProfile, userID)
	var i Profile
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Dob,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.PrimaryEmail,
		&i.SecondaryEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProfiles = `-- name: ListProfiles :many
SELECT user_id, first_name, last_name, dob, address_line1, address_line2, city, state, country, postal_code, primary_phone, secondary_phone, primary_email, secondary_email, created_at, updated_at FROM profiles LIMIT $1 OFFSET $2
`

type ListProfilesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProfiles(ctx context.Context, arg ListProfilesParams) ([]Profile, error) {
	rows, err := q.query(ctx, q.listProfilesStmt, listProfiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Profile{}
	for rows.Next() {
		var i Profile
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Dob,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.PrimaryPhone,
			&i.SecondaryPhone,
			&i.PrimaryEmail,
			&i.SecondaryEmail,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfile = `-- name: UpdateProfile :exec
UPDATE profiles
SET
first_name= $1,
last_name= $2,
dob= $3,
address_line1= $4,
address_line2= $5,
city= $6,
state= $7,
country= $8,
postal_code= $9,
primary_phone= $10,
secondary_phone= $11,
primary_email= $12,
secondary_email= $13,
updated_at = $14
WHERE user_id = $15
`

type UpdateProfileParams struct {
	FirstName      string      `json:"first_name"`
	LastName       string      `json:"last_name"`
	Dob            time.Time   `json:"dob"`
	AddressLine1   string      `json:"address_line1"`
	AddressLine2   string      `json:"address_line2"`
	City           string      `json:"city"`
	State          string      `json:"state"`
	Country        string      `json:"country"`
	PostalCode     string      `json:"postal_code"`
	PrimaryPhone   string      `json:"primary_phone"`
	SecondaryPhone string      `json:"secondary_phone"`
	PrimaryEmail   string      `json:"primary_email"`
	SecondaryEmail string      `json:"secondary_email"`
	UpdatedAt      interface{} `json:"updated_at"`
	UserID         string      `json:"user_id"`
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) error {
	_, err := q.exec(ctx, q.updateProfileStmt, updateProfile,
		arg.FirstName,
		arg.LastName,
		arg.Dob,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.Country,
		arg.PostalCode,
		arg.PrimaryPhone,
		arg.SecondaryPhone,
		arg.PrimaryEmail,
		arg.SecondaryEmail,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}
